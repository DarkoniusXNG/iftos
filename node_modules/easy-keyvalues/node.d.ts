declare class KeyValuesComments {
    protected comments: string[];
    protected endOfLineComment: string;
    constructor(comments?: string[], endOfLineComment?: string);
    GetComments(): string[];
    HasComments(): boolean;
    SetComments(list: string[]): this;
    AppendComment(text: string): this;
    SetEndOfLineComment(text: string): this;
    GetEndOfLineComment(): string;
    HasEndOfLineComment(): boolean;
}
declare class KeyValues3Comments {
    protected comments: string[];
    protected endOfLineComment: string;
    constructor(comments?: string[], endOfLineComment?: string);
    GetComments(): string[];
    HasComments(): boolean;
    SetComments(list: string[]): this;
    AppendComment(text: string): this;
    SetEndOfLineComment(text: string): this;
    GetEndOfLineComment(): string;
    HasEndOfLineComment(): boolean;
    Format(tab?: string): string;
}

declare class KeyValues {
    Key: string;
    private __filename?;
    get filename(): string | undefined;
    set filename(s: string | undefined);
    /**
     * The children of this KeyValues
     */
    protected children?: KeyValues[];
    /**
     * The value of this KeyValues
     */
    protected value?: string;
    /**
     * The parent of this KeyValues,
     */
    protected parent?: KeyValues;
    /**
     * Comment
     */
    Comments: KeyValuesComments;
    /**
     * The KeyValues flags, such as [$WIN32] [$X360]
     */
    Flags: string;
    /**
     * Unique id of KeyValues
     */
    readonly ID: string;
    constructor(Key: string, defaultValue?: string | KeyValues[]);
    /**
     * The parent of this KeyValues
     */
    GetParent(): KeyValues | undefined;
    /**
     * Return true that the KeyValues is root.
     */
    IsRoot(): boolean;
    /**
     * The key is #base?
     */
    IsBase(): boolean;
    protected baseFilePath: string;
    /**
     * Return #base's value
     */
    GetBaseFilePath(): string;
    /**
     * KeyValues list of #base
     */
    GetBaseList(): KeyValues[];
    /**
     * The children of this KeyValues,
     * if no children then return empty array.
     */
    GetChildren(): Readonly<KeyValues[]>;
    GetChildCount(): number;
    GetFirstChild(): KeyValues | undefined;
    GetLastChild(): KeyValues | undefined;
    /**
     * Create a KeyValues to children and return it.
     */
    CreateChild(key: string, value: string | KeyValues[]): KeyValues;
    /**
     * The value of this KeyValues,
     * if no value then return empty string.
     */
    GetValue(): string;
    /**
     * Return true that the KeyValues exists children and no value.
     */
    HasChildren(): boolean;
    /**
     * Set value or children.
     */
    SetValue(v: string | KeyValues[]): this;
    /**
     * Append a KeyValues to children,
     * if no children then throw error.
     */
    Append(child: KeyValues): this;
    /**
     * Insert a KeyValues to children,
     * if no children then throw error.
     */
    Insert(child: KeyValues, index: number): this;
    /**
     * Find a KeyValues from children
     */
    Find(callback: (kv: KeyValues, i: number, parent: KeyValues) => boolean): KeyValues | undefined;
    /**
     * Find all KeyValues from children
     */
    FindAll(callback: (kv: KeyValues, i: number, parent: KeyValues) => boolean): KeyValues[];
    /**
     * Find a KeyValues
     */
    FindKey(key: string): KeyValues | undefined;
    /**
     * Find all KeyValues
     */
    FindAllKeys(...keys: string[]): KeyValues[];
    /**
     * Find a KeyValues from children and children's children...
     */
    FindTraverse(callback: (kv: KeyValues, i: number, parent: KeyValues) => boolean): KeyValues | undefined;
    /**
     * Find a KeyValues from children and children's children...
     */
    protected static FindTraverse(root: KeyValues, callback: (kv: KeyValues, i: number, parent: KeyValues) => boolean): KeyValues | undefined;
    /**
     * Find child from the current KeyValues
     */
    FindID(id: string): KeyValues | undefined;
    /**
     * Recursively iterate through all children to find the value that matches the ID
     */
    FindIDTraverse(id: string): KeyValues | undefined;
    /**
     * Delete a KeyValues from children
     */
    Delete(child: string | KeyValues): KeyValues | undefined;
    /**
     * Delete this KeyValues from parent
     */
    Free(): this;
    /**
     * Format KeyValues to file text
     */
    Format(tab?: string, maxLength?: number): string;
    toString(): string;
    /**
     * Deep clone KeyValues
     */
    Clone(): KeyValues;
    /**
     * Create root node
     */
    static CreateRoot(): KeyValues;
    /**
     * Parse string
     */
    static Parse(body: string, filename?: string): Promise<KeyValues>;
    protected static _parse(data: {
        body: string;
        pos: number;
        line: number;
    }, parent: KeyValues): void;
    /**
     * Convert KeyValues to object and exclude comments.
     */
    toObject<T = any>(): T;
    /**
     * Load KeyValues from file
     */
    static Load(filename: string, encoding?: string): Promise<KeyValues>;
    /**
     * Save KeyValues to file
     */
    Save(otherFilename?: string, encoding?: string): Promise<void>;
}

interface IKV3Value {
    Comments: KeyValues3Comments;
    Value(): any;
    GetOwner(): KeyValues3 | undefined;
    SetOwner(owner: KeyValues3 | undefined): void;
    IsBoolean(): this is ValueBoolean;
    IsInt(): this is ValueInt;
    IsDouble(): this is ValueDouble;
    IsString(): this is ValueString;
    IsFeature(): this is ValueFeature;
    IsArray(): this is ValueArray;
    IsObject(): this is ValueObject;
    IsNull(): this is ValueNull;
    Format(): string;
    Clone(): IKV3Value;
}
declare class KV3BaseValue implements IKV3Value {
    protected value: any;
    protected owner?: KeyValues3;
    Comments: KeyValues3Comments;
    constructor(owner?: KeyValues3);
    Value(): any;
    GetOwner(): KeyValues3 | undefined;
    SetOwner(owner: KeyValues3 | undefined): void;
    IsBoolean(): this is ValueBoolean;
    IsInt(): this is ValueInt;
    IsDouble(): this is ValueDouble;
    IsString(): this is ValueString;
    IsFeature(): this is ValueFeature;
    IsArray(): this is ValueArray;
    IsObject(): this is ValueObject;
    IsNull(): this is ValueNull;
    Format(): string;
    Clone(): KV3BaseValue;
}
/**
 * Null
 */
declare class ValueNull extends KV3BaseValue {
    constructor();
    Value(): null;
    Format(): string;
    Clone(): ValueNull;
}
/**
 * String
 */
declare class ValueString extends KV3BaseValue {
    protected value: string;
    constructor(initValue?: string);
    Value(): string;
    SetValue(v: string): this;
    Format(): string;
    Clone(): ValueString;
}
/**
 * Boolean
 */
declare class ValueBoolean extends KV3BaseValue {
    protected value: boolean;
    constructor(initValue?: boolean);
    Value(): boolean;
    SetValue(v: boolean): this;
    Clone(): ValueBoolean;
}
/**
 * Int
 */
declare class ValueInt extends KV3BaseValue {
    protected value: number;
    constructor(initValue?: number);
    Value(): number;
    SetValue(v: number): this;
    Clone(): ValueInt;
}
/**
 * Double
 */
declare class ValueDouble extends KV3BaseValue {
    protected value: number;
    constructor(initValue?: number);
    Value(): number;
    SetValue(v: number): this;
    Format(): string;
    Clone(): ValueDouble;
}
/**
 * Similar values:
 * resource:""
 * deferred_resource:""
 * soundevent:""
 */
declare class ValueFeature extends KV3BaseValue {
    Feature: string;
    protected value: string;
    constructor(Feature?: string, initValue?: string);
    Value(): string;
    SetValue(v: string): this;
    Format(): string;
    Clone(): ValueFeature;
}
/**
 * Array
 */
declare class ValueArray extends KV3BaseValue {
    protected value: IKV3Value[];
    constructor(initValue?: IKV3Value[]);
    Value(): Readonly<IKV3Value[]>;
    SetValue(list: IKV3Value[]): this;
    Append(...kv: IKV3Value[]): this;
    Insert(index: number, ...kv: IKV3Value[]): this;
    Delete(v: IKV3Value): this;
    /**
     * Recursively iterate through all children to find the value that matches the ID
     */
    FindIDTraverse(id: string): KeyValues3 | undefined;
    /**
     * Recursively iterate through all children to find the value that matches the callback
     */
    Search(callback: (v: IKV3Value) => boolean): IKV3Value | undefined;
    Get(index: number): IKV3Value | undefined;
    Format(tab?: string): string;
    /**
     * Convert to javascript array
     */
    toArray(): any;
    Clone(): ValueArray;
}
/**
 * Object
 */
declare class ValueObject extends KV3BaseValue {
    protected value: KeyValues3[];
    constructor(initValue?: KeyValues3[]);
    Value(): Readonly<KeyValues3[]>;
    SetValue(list: KeyValues3[]): this;
    Create(key: string, value: IKV3Value): KeyValues3;
    Append(...kv: KeyValues3[]): this;
    Insert(index: number, ...kv: KeyValues3[]): this;
    Delete(v: string | KeyValues3): KeyValues3 | undefined;
    Get(index: number): KeyValues3 | undefined;
    /**
     * Find a KeyValues3
     */
    Find(callback: (kv: KeyValues3, i: number, parent: ValueObject) => boolean): KeyValues3 | undefined;
    /**
     * Find a KeyValues3
     */
    FindKey(key: string): KeyValues3 | undefined;
    /**
     * Find a KeyValues3
     */
    FindAll(callback: (kv: KeyValues3, i: number, parent: ValueObject) => boolean): KeyValues3[];
    /**
     * Find a KeyValues3
     */
    FindAllKeys(...keys: string[]): KeyValues3[];
    /**
     * Recursively iterate through all children to find the value that matches the ID
     */
    FindIDTraverse(id: string): KeyValues3 | undefined;
    /**
     * Recursively iterate through all children to find the value that matches the callback
     */
    Search(callback: (value: IKV3Value) => boolean): IKV3Value | undefined;
    Format(tab?: string): string;
    /**
     * Convert to javascript object
     */
    toObject(): any;
    Clone(): ValueObject;
}
/**
 * https://developer.valvesoftware.com/wiki/Dota_2_Workshop_Tools/KeyValues3
 */
declare class KeyValues3 {
    Key: string;
    static String(value?: string): ValueString;
    static Boolean(value?: boolean): ValueBoolean;
    static Int(value?: number): ValueInt;
    static Double(value?: number): ValueDouble;
    static Feature(feature: string, value?: string): ValueFeature;
    static Array(value?: IKV3Value[]): ValueArray;
    static Object(value?: KeyValues3[]): ValueObject;
    static Null(): ValueNull;
    private __filename?;
    get filename(): string | undefined;
    set filename(s: string | undefined);
    protected value: IKV3Value;
    protected header?: string;
    /**
     * Unique id of KeyValues3
     */
    readonly ID: string;
    constructor(Key: string, defaultValue: IKV3Value);
    IsRoot(): boolean;
    GetHeader(): string | undefined;
    static CreateRoot(): KeyValues3;
    static CommonHeader: string;
    GetValue(): IKV3Value;
    /**
     * Return when value is ValueObject, otherwise throw an error.
     */
    GetObject(): ValueObject;
    /**
     * Return when value is ValueArray, otherwise throw an error.
     */
    GetArray(): ValueArray;
    SetValue(v: IKV3Value): void;
    CreateObjectValue(key: string, value: IKV3Value): KeyValues3;
    AppendValue(...values: IKV3Value[]): ValueArray;
    Find(callback: (kv: KeyValues3, i: number, parent: ValueObject) => boolean): KeyValues3 | undefined;
    FindKey(key: string): KeyValues3 | undefined;
    FindAll(callback: (kv: KeyValues3, i: number, parent: ValueObject) => boolean): KeyValues3[];
    FindAllKeys(...keys: string[]): KeyValues3[];
    /**
     * Find child from the current KeyValues3
     */
    FindID(id: string): KeyValues3 | undefined;
    /**
     * Recursively iterate through all children to find the value that matches the ID
     */
    FindIDTraverse(id: string): KeyValues3 | undefined;
    /**
     * Recursively iterate through all children to find the value that matches the callback
     */
    Search(callback: (value: IKV3Value) => boolean): IKV3Value | undefined;
    Format(tab?: string): string;
    toString(): string;
    /**
     * Convert KeyValues3 to object and exclude comments.
     * If the value of KeyValues3 is not object or array, then return object,
     * which has only the key and value of KeyValues3
     */
    toObject<T = any>(): T;
    /**
     * Deep clone KeyValues3
     */
    Clone(): KeyValues3;
    /**
     * Parse text of KeyValues3
     */
    static Parse(body: string, filename?: string): KeyValues3;
    protected static _parse(parent: KeyValues3, data: {
        body: string;
        line: number;
        pos: number;
        tokenCounter: number;
    }): void;
    protected static _parse_error(line: number, msg: string): string;
    /**
     * Load KeyValues3 from file
     */
    static Load(filename: string, encoding?: string): Promise<KeyValues3>;
    /**
     * Save KeyValues3 to file
     */
    Save(otherFilename?: string, encoding?: string): Promise<void>;
}

interface KeyValuesAdapter {
    readFile(path: string, encoding?: string): Promise<string>;
    writeFile(path: string, data: string, encoding?: string): Promise<void>;
    resolvePath(filename: string, basePath: string): string;
    createKeyValuesID(): string;
}
declare function setKeyValuesAdapter(adapter: KeyValuesAdapter): void;
declare function getKeyValuesAdapter(): KeyValuesAdapter;

export { KeyValues, KeyValues3, KeyValues3Comments, type KeyValuesAdapter, KeyValuesComments, getKeyValuesAdapter, setKeyValuesAdapter };
